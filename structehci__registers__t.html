<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>tinyusb: ehci_registers_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">tinyusb
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structehci__registers__t.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">ehci_registers_t Struct Reference<div class="ingroups"><a class="el" href="group___e_h_c_i.html">EHCI</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a7687b74405f0ac78c3f6d8d7d41dc433"><td class="memItemLeft" ><a class="anchor" id="a7687b74405f0ac78c3f6d8d7d41dc433"></a>
union {</td></tr>
<tr class="memitem:ada89558b4ff38af9168f5c527b645fe0"><td class="memItemLeft" ><a class="anchor" id="ada89558b4ff38af9168f5c527b645fe0"></a>
&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#ada89558b4ff38af9168f5c527b645fe0">usb_cmd</a></td></tr>
<tr class="memdesc:ada89558b4ff38af9168f5c527b645fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Command Register indicates the command to be executed by the serial bus host controller. Writing to the register causes a command to be executed. <br/></td></tr>
<tr class="separator:ada89558b4ff38af9168f5c527b645fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841d4bbe3c2b10d88631ec4dc0c3bcdd"><td class="memItemLeft" ><a class="anchor" id="a841d4bbe3c2b10d88631ec4dc0c3bcdd"></a>
&#160;&#160;&#160;struct {</td></tr>
<tr class="memitem:ab26cb1fa665863b363c7da77a5b392ce"><td class="memItemLeft" ><a class="anchor" id="ab26cb1fa665863b363c7da77a5b392ce"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#ab26cb1fa665863b363c7da77a5b392ce">run_stop</a>: 1</td></tr>
<tr class="memdesc:ab26cb1fa665863b363c7da77a5b392ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default 0b. 1=Run. 0=Stop. When set to a 1, the Host Controller proceeds with execution of the schedule. The Host Controller continues execution as long as this bit is set to a 1. When this bit is set to 0, the Host Controller completes the current and any actively pipelined transactions on the USB and then halts. The Host Controller must halt within 16 micro-frames after software clears the Run bit. The HC Halted bit in the status register indicates when the Host Controller has finished its pending pipelined transactions and has entered the stopped state. Software must not write a one to this field unless the host controller is in the Halted state (i.e. HCHaltedin the USBSTS register is a one). Doing so will yield undefined results. <br/></td></tr>
<tr class="separator:ab26cb1fa665863b363c7da77a5b392ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0110dfcd1a7cfdd3fae2a5676f7901d"><td class="memItemLeft" ><a class="anchor" id="aa0110dfcd1a7cfdd3fae2a5676f7901d"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#aa0110dfcd1a7cfdd3fae2a5676f7901d">reset</a>: 1</td></tr>
<tr class="memdesc:aa0110dfcd1a7cfdd3fae2a5676f7901d"><td class="mdescLeft">&#160;</td><td class="mdescRight">his control bit is used by software to reset the host controller. The effects of this on Root Hub registers are similar to a Chip Hardware Reset. When software writes a one to this bit, the Host Controller resets its internal pipelines, timers, counters, state machines, etc. to their initial value. Any transaction currently in progress on USB is immediately terminated. A USB reset is not driven on downstream ports.This bit is set to zero by the Host Controller when the reset process is complete. Software cannot terminate the reset process early by writing a zero to this register. Software should not set this bit to a one when the HCHaltedbit in the USBSTS register is a zero. Attempting to reset an actively running host controller will result in undefined behavior. <br/></td></tr>
<tr class="separator:aa0110dfcd1a7cfdd3fae2a5676f7901d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26cf3cf2046b927138dba0f440b891f3"><td class="memItemLeft" ><a class="anchor" id="a26cf3cf2046b927138dba0f440b891f3"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a26cf3cf2046b927138dba0f440b891f3">framelist_size</a>: 2</td></tr>
<tr class="memdesc:a26cf3cf2046b927138dba0f440b891f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This field is R/W only if Programmable Frame List Flagin the HCCPARAMS registers is set to a one. This field specifies the size of the frame list.00b 1024 elements (4096 bytes) Default value 01b 512 elements (2048 bytes) 10b 256 elements (1024 bytes) <br/></td></tr>
<tr class="separator:a26cf3cf2046b927138dba0f440b891f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f7584ab8fd138bb00285662d66e38d"><td class="memItemLeft" ><a class="anchor" id="a81f7584ab8fd138bb00285662d66e38d"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a81f7584ab8fd138bb00285662d66e38d">periodic_enable</a>: 1</td></tr>
<tr class="memdesc:a81f7584ab8fd138bb00285662d66e38d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This bit controls whether the host controller skips processing the Periodic Schedule. Values mean: 0b Do not process the Periodic Schedule 1b Use the PERIODICLISTBASE register to access the Periodic Schedule. <br/></td></tr>
<tr class="separator:a81f7584ab8fd138bb00285662d66e38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20cc16928400153e12bd87ea837b3a31"><td class="memItemLeft" ><a class="anchor" id="a20cc16928400153e12bd87ea837b3a31"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a20cc16928400153e12bd87ea837b3a31">async_enable</a>: 1</td></tr>
<tr class="memdesc:a20cc16928400153e12bd87ea837b3a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">This bit controls whether the host controller skips processing the Asynchronous Schedule. Values mean: 0b Do not process the Asynchronous Schedule 1b Use the ASYNCLISTADDR register to access the Asynchronous Schedule. <br/></td></tr>
<tr class="separator:a20cc16928400153e12bd87ea837b3a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570c11c54b30adf4623cb3cf401f9f7a"><td class="memItemLeft" ><a class="anchor" id="a570c11c54b30adf4623cb3cf401f9f7a"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a570c11c54b30adf4623cb3cf401f9f7a">advacne_async</a>: 1</td></tr>
<tr class="memdesc:a570c11c54b30adf4623cb3cf401f9f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This bit is used as a doorbell by software to tell the host controller to issue an interrupt the next time it advances asynchronous schedule. Software must write a 1 to this bit to ringthe doorbell. When the host controller has evicted all appropriate cached schedule state, it sets the Interrupt on Async Advancestatus bit in the USBSTS register. If the Interrupt on Async Advance Enablebit in the USBINTR register is a one then the host controller will assert an interrupt at the next interrupt threshold. See Section 4.8.2 for operational details. The host controller sets this bit to a zero after it has set the Interrupt on Async Advance status bit in the USBSTS register to a one. Software should not write a one to this bit when the asynchronous schedule is disabled. Doing so will yield undefined results. <br/></td></tr>
<tr class="separator:a570c11c54b30adf4623cb3cf401f9f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97aaaf2d3184d2fe1a0cdcfc2475353a"><td class="memItemLeft" ><a class="anchor" id="a97aaaf2d3184d2fe1a0cdcfc2475353a"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a97aaaf2d3184d2fe1a0cdcfc2475353a">light_reset</a>: 1</td></tr>
<tr class="memdesc:a97aaaf2d3184d2fe1a0cdcfc2475353a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This control bit is not required. If implemented, it allows the driver to reset the EHCI controller without affecting the state of the ports or the relationship to the companion host controllers. For example, the PORSTC registers should not be reset to their default values and the CF bit setting should not go to zero (retaining port ownership relationships). A host software read of this bit as zero indicates the Light Host Controller Reset has completed and it is safe for host software to re-initialize the host controller. A host software read of this bit as a one indicates the Light Host Controller Reset has not yet completed. <br/></td></tr>
<tr class="separator:a97aaaf2d3184d2fe1a0cdcfc2475353a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46244e8912f2a1ef3e4aa8c713e9da7"><td class="memItemLeft" ><a class="anchor" id="aa46244e8912f2a1ef3e4aa8c713e9da7"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#aa46244e8912f2a1ef3e4aa8c713e9da7">async_park</a>: 2</td></tr>
<tr class="memdesc:aa46244e8912f2a1ef3e4aa8c713e9da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">It contains a count of the number of successive transactions the host controller is allowed to execute from a high-speed queue head on the Asynchronous schedule before continuing traversal of the Asynchronous schedule. See Section 4.10.3.2 for full operational details. Valid values are 1h to 3h. Software must not write a zero to this bit when Park Mode Enableis a one as this will result in undefined behavior. <br/></td></tr>
<tr class="separator:aa46244e8912f2a1ef3e4aa8c713e9da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e57c2ef1c3ffb36722f000cc1156824"><td class="memItemLeft" ><a class="anchor" id="a3e57c2ef1c3ffb36722f000cc1156824"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a3e57c2ef1c3ffb36722f000cc1156824">__pad0__</a>: 1</td></tr>
<tr class="memdesc:a3e57c2ef1c3ffb36722f000cc1156824"><td class="mdescLeft">&#160;</td><td class="mdescRight">reserved <br/></td></tr>
<tr class="separator:a3e57c2ef1c3ffb36722f000cc1156824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adbfb23660f8e985630328cd13af567"><td class="memItemLeft" ><a class="anchor" id="a3adbfb23660f8e985630328cd13af567"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a3adbfb23660f8e985630328cd13af567">async_park_enable</a>: 1</td></tr>
<tr class="memdesc:a3adbfb23660f8e985630328cd13af567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Software uses this bit to enable or disable Park mode. When this bit is one, Park mode is enabled. When this bit is a zero, Park mode is disabled. <br/></td></tr>
<tr class="separator:a3adbfb23660f8e985630328cd13af567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6712ba6dd1d5b43d2d56ff8ac4e275a7"><td class="memItemLeft" ><a class="anchor" id="a6712ba6dd1d5b43d2d56ff8ac4e275a7"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a6712ba6dd1d5b43d2d56ff8ac4e275a7">__pad1__</a>: 3</td></tr>
<tr class="memdesc:a6712ba6dd1d5b43d2d56ff8ac4e275a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">reserved <br/></td></tr>
<tr class="separator:a6712ba6dd1d5b43d2d56ff8ac4e275a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ab62a462e64f28df918448be8c192b"><td class="memItemLeft" ><a class="anchor" id="a85ab62a462e64f28df918448be8c192b"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a85ab62a462e64f28df918448be8c192b">nxp_framelist_size_msb</a>: 1</td></tr>
<tr class="memdesc:a85ab62a462e64f28df918448be8c192b"><td class="mdescLeft">&#160;</td><td class="mdescRight">NXP customized : Bit 2 of the Frame List Size bits <br/>
 011b: 128 elements <br/>
 100b: 64 elements <br/>
 101b: 32 elements <br/>
 110b: 16 elements <br/>
 111b: 8 elements. <br/></td></tr>
<tr class="separator:a85ab62a462e64f28df918448be8c192b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9b8039a32122dcaee39c8774adeb23"><td class="memItemLeft" ><a class="anchor" id="abb9b8039a32122dcaee39c8774adeb23"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#abb9b8039a32122dcaee39c8774adeb23">int_threshold</a>: 8</td></tr>
<tr class="memdesc:abb9b8039a32122dcaee39c8774adeb23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default 08h. This field is used by system software to select the maximum rate at which the host controller will issue interrupts. The only valid values are defined below. If software writes an invalid value to this register, the results are undefined. Value Maximum Interrupt Interval 00h Reserved 01h 1 micro-frame 02h 2 micro-frames 04h 4 micro-frames 08h 8 micro-frames (default, equates to 1 ms) 10h 16 micro-frames (2 ms) 20h 32 micro-frames (4 ms) 40h 64 micro-frames (8 ms) Refer to Section 4.15 for interrupts affected by this register. Any other value in this register yields undefined results. Software modifications to this bit while HCHalted bit is equal to zero results in undefined behavior. <br/></td></tr>
<tr class="separator:abb9b8039a32122dcaee39c8774adeb23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce12a63de64ef64ae2d59d128251cae"><td class="memItemLeft" ><a class="anchor" id="a9ce12a63de64ef64ae2d59d128251cae"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>__pad2__</b>: 0</td></tr>
<tr class="separator:a9ce12a63de64ef64ae2d59d128251cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841d4bbe3c2b10d88631ec4dc0c3bcdd"><td class="memItemLeft" valign="top">&#160;&#160;&#160;}&#160;&#160;&#160;<b>usb_cmd_bit</b></td></tr>
<tr class="separator:a841d4bbe3c2b10d88631ec4dc0c3bcdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7687b74405f0ac78c3f6d8d7d41dc433"><td class="memItemLeft" valign="top">};&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:a7687b74405f0ac78c3f6d8d7d41dc433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf67841f7fedc2644841617697bf35c"><td class="memItemLeft" ><a class="anchor" id="addf67841f7fedc2644841617697bf35c"></a>
union {</td></tr>
<tr class="memitem:a8758e103afb55f598eeb082f60537d78"><td class="memItemLeft" ><a class="anchor" id="a8758e103afb55f598eeb082f60537d78"></a>
&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a8758e103afb55f598eeb082f60537d78">usb_sts</a></td></tr>
<tr class="memdesc:a8758e103afb55f598eeb082f60537d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">This register indicates pending interrupts and various states of the Host Controller. The status resulting from a transaction on the serial bus is not indicated in this register. Software sets a bit to 0 in this register by writing a 1 to it. See Section 4.15 for additional information concerning USB interrupt conditions. <br/></td></tr>
<tr class="separator:a8758e103afb55f598eeb082f60537d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722aaf0c653219b547b7ff2984ae6ab7"><td class="memItemLeft" ><a class="anchor" id="a722aaf0c653219b547b7ff2984ae6ab7"></a>
&#160;&#160;&#160;struct {</td></tr>
<tr class="memitem:a6e60f608783dd4476b3b8ecab7066eb3"><td class="memItemLeft" ><a class="anchor" id="a6e60f608783dd4476b3b8ecab7066eb3"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a6e60f608783dd4476b3b8ecab7066eb3">usb</a>: 1</td></tr>
<tr class="memdesc:a6e60f608783dd4476b3b8ecab7066eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">R/WC The Host Controller sets this bit to 1 on the completion of a USB transaction, which results in the retirement of a Transfer Descriptor that had its IOC bit set. <br/>
 The Host Controller also sets this bit to 1 when a short packet is detected (actual number of bytes received was less than the expected number of bytes). <br/></td></tr>
<tr class="separator:a6e60f608783dd4476b3b8ecab7066eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fedc196af2d4d152fd32b0783c78d7f"><td class="memItemLeft" ><a class="anchor" id="a6fedc196af2d4d152fd32b0783c78d7f"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a6fedc196af2d4d152fd32b0783c78d7f">usb_error</a>: 1</td></tr>
<tr class="memdesc:a6fedc196af2d4d152fd32b0783c78d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">R/WC The Host Controller sets this bit to 1 when completion of a USB transaction results in an error condition (e.g., error counter underflow). If the TD on which the error interrupt occurred also had its IOC bit set, both this bit and USBINT bit are set. See Section 4.15.1 for a list of the USB errors that will result in this bit being set to a one. <br/></td></tr>
<tr class="separator:a6fedc196af2d4d152fd32b0783c78d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa893558e628e58f2f183cbedbf4863b7"><td class="memItemLeft" ><a class="anchor" id="aa893558e628e58f2f183cbedbf4863b7"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#aa893558e628e58f2f183cbedbf4863b7">port_change_detect</a>: 1</td></tr>
<tr class="memdesc:aa893558e628e58f2f183cbedbf4863b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">R/WC The Host Controller sets this bit to a one when any port for which the Port Ownerbit is set to zero (see Section 2.3.9) has a change bit transition from a zero to a one or a Force Port Resumebit transition from a zero to a one as a result of a J-K transition detected on a suspended port. <br/></td></tr>
<tr class="separator:aa893558e628e58f2f183cbedbf4863b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc16f083b47d7336fb7e70a2cc2ccc7"><td class="memItemLeft" ><a class="anchor" id="abbc16f083b47d7336fb7e70a2cc2ccc7"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#abbc16f083b47d7336fb7e70a2cc2ccc7">framelist_rollover</a>: 1</td></tr>
<tr class="memdesc:abbc16f083b47d7336fb7e70a2cc2ccc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">R/WC The Host Controller sets this bit to a one when the Frame List Index(see Section 2.3.4) rolls over from its maximum value to zero. The exact value at which the rollover occurs depends on the frame list size. For example, if the frame list size (as programmed in the Frame List Sizefield of the USBCMD register) is 1024, the Frame Index Registerrolls over every time FRINDEX[13] toggles. Similarly, if the size is 512, the Host Controller sets this bit to a one every time FRINDEX[12] toggles. <br/></td></tr>
<tr class="separator:abbc16f083b47d7336fb7e70a2cc2ccc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fa66147939da3bd3f7e84d4c79fd43"><td class="memItemLeft" ><a class="anchor" id="ac1fa66147939da3bd3f7e84d4c79fd43"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#ac1fa66147939da3bd3f7e84d4c79fd43">pci_host_system_error</a>: 1</td></tr>
<tr class="memdesc:ac1fa66147939da3bd3f7e84d4c79fd43"><td class="mdescLeft">&#160;</td><td class="mdescRight">R/WC (not used by NXP) The Host Controller sets this bit to 1 when a serious error occurs during a host system access involving the Host Controller module. In a PCI system, conditions that set this bit to 1 include PCI Parity error, PCI Master Abort, and PCI Target Abort. When this error occurs, the Host Controller clears the Run/Stop bit in the Command register to prevent further execution of the scheduled TDs. <br/></td></tr>
<tr class="separator:ac1fa66147939da3bd3f7e84d4c79fd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6607680de70be131c44e27cc2f2c3cd"><td class="memItemLeft" ><a class="anchor" id="ac6607680de70be131c44e27cc2f2c3cd"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#ac6607680de70be131c44e27cc2f2c3cd">async_advance</a>: 1</td></tr>
<tr class="memdesc:ac6607680de70be131c44e27cc2f2c3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">R/WC 0=Default. System software can force the host controller to issue an interrupt the next time the host controller advances the asynchronous schedule by writing a one to the Interrupt on Async Advance Doorbell bit in the USBCMD register. This status bit indicates the assertion of that interrupt source. <br/></td></tr>
<tr class="separator:ac6607680de70be131c44e27cc2f2c3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e57c2ef1c3ffb36722f000cc1156824"><td class="memItemLeft" ><a class="anchor" id="a3e57c2ef1c3ffb36722f000cc1156824"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a3e57c2ef1c3ffb36722f000cc1156824">__pad0__</a>: 1</td></tr>
<tr class="memdesc:a3e57c2ef1c3ffb36722f000cc1156824"><td class="mdescLeft">&#160;</td><td class="mdescRight">These bits are reserved and should be set to zero. <br/></td></tr>
<tr class="separator:a3e57c2ef1c3ffb36722f000cc1156824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48bc1a0f022be1211fb852bd1d96965"><td class="memItemLeft" ><a class="anchor" id="ac48bc1a0f022be1211fb852bd1d96965"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#ac48bc1a0f022be1211fb852bd1d96965">nxp_int_sof</a>: 1</td></tr>
<tr class="memdesc:ac48bc1a0f022be1211fb852bd1d96965"><td class="mdescLeft">&#160;</td><td class="mdescRight">R/WC NXP customized: this bit will be set every 125us and can be used by host controller driver as a time base. <br/></td></tr>
<tr class="separator:ac48bc1a0f022be1211fb852bd1d96965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6712ba6dd1d5b43d2d56ff8ac4e275a7"><td class="memItemLeft" ><a class="anchor" id="a6712ba6dd1d5b43d2d56ff8ac4e275a7"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a6712ba6dd1d5b43d2d56ff8ac4e275a7">__pad1__</a>: 4</td></tr>
<tr class="memdesc:a6712ba6dd1d5b43d2d56ff8ac4e275a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">These bits are reserved and should be set to zero. <br/></td></tr>
<tr class="separator:a6712ba6dd1d5b43d2d56ff8ac4e275a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2938b949325ea9f33aac8c53b890cc1b"><td class="memItemLeft" ><a class="anchor" id="a2938b949325ea9f33aac8c53b890cc1b"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a2938b949325ea9f33aac8c53b890cc1b">hc_halted</a>: 1</td></tr>
<tr class="memdesc:a2938b949325ea9f33aac8c53b890cc1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-Only 1=Default. This bit is a zero whenever the Run/Stop bit is a one. The Host Controller sets this bit to one after it has stopped executing as a result of the Run/Stop bit being set to 0, either by software or by the Host Controller hardware (e.g. internal error). <br/></td></tr>
<tr class="separator:a2938b949325ea9f33aac8c53b890cc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079482937c99b8f2d01747fd5fefa6f4"><td class="memItemLeft" ><a class="anchor" id="a079482937c99b8f2d01747fd5fefa6f4"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a079482937c99b8f2d01747fd5fefa6f4">reclamation</a>: 1</td></tr>
<tr class="memdesc:a079482937c99b8f2d01747fd5fefa6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-Only 0=Default. This is a read-only status bit, which is used to detect an empty asynchronous schedule. The operational model of empty schedule detection is described in Section 4.8.3. The valid transitions for this bit are described in Section 4.8.6. <br/></td></tr>
<tr class="separator:a079482937c99b8f2d01747fd5fefa6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2613e1c7cd4e2aa2196cdb773b3d0c"><td class="memItemLeft" ><a class="anchor" id="a1e2613e1c7cd4e2aa2196cdb773b3d0c"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a1e2613e1c7cd4e2aa2196cdb773b3d0c">period_schedule_status</a>: 1</td></tr>
<tr class="memdesc:a1e2613e1c7cd4e2aa2196cdb773b3d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-Only The bit reports the current real status of the Periodic Schedule. If this bit is a zero then the status of the Periodic Schedule is disabled. If this bit is a one then the status of the Periodic Schedule is enabled. <br/></td></tr>
<tr class="separator:a1e2613e1c7cd4e2aa2196cdb773b3d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050fbd190c90a33c1bbc35b5f82f17fa"><td class="memItemLeft" ><a class="anchor" id="a050fbd190c90a33c1bbc35b5f82f17fa"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a050fbd190c90a33c1bbc35b5f82f17fa">async_schedule_status</a>: 1</td></tr>
<tr class="memdesc:a050fbd190c90a33c1bbc35b5f82f17fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read-Only 0=Default. The bit reports the current real status of the Asynchronous Schedule. If this bit is a zero then the status of the Asynchronous Schedule is disabled. If this bit is a one then the status of the Asynchronous Schedule is enabled. <br/></td></tr>
<tr class="separator:a050fbd190c90a33c1bbc35b5f82f17fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce12a63de64ef64ae2d59d128251cae"><td class="memItemLeft" ><a class="anchor" id="a9ce12a63de64ef64ae2d59d128251cae"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a9ce12a63de64ef64ae2d59d128251cae">__pad2__</a>: 2</td></tr>
<tr class="memdesc:a9ce12a63de64ef64ae2d59d128251cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">reseved <br/></td></tr>
<tr class="separator:a9ce12a63de64ef64ae2d59d128251cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f31fc1313f1e389a03738c07b9e325"><td class="memItemLeft" ><a class="anchor" id="ae7f31fc1313f1e389a03738c07b9e325"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#ae7f31fc1313f1e389a03738c07b9e325">nxp_int_async</a>: 1</td></tr>
<tr class="memdesc:ae7f31fc1313f1e389a03738c07b9e325"><td class="mdescLeft">&#160;</td><td class="mdescRight">R/WC NXP customized: This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set andthe TD was from the asynchronous schedule. This bit is also set by the Host when a short packet is detected andthe packet is on the asynchronous schedule. <br/></td></tr>
<tr class="separator:ae7f31fc1313f1e389a03738c07b9e325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404c78dabf4df19e0cb2dd66d514848f"><td class="memItemLeft" ><a class="anchor" id="a404c78dabf4df19e0cb2dd66d514848f"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a404c78dabf4df19e0cb2dd66d514848f">nxp_int_period</a>: 1</td></tr>
<tr class="memdesc:a404c78dabf4df19e0cb2dd66d514848f"><td class="mdescLeft">&#160;</td><td class="mdescRight">R/WC NXP customized: This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set andthe TD was from the periodic schedule. <br/></td></tr>
<tr class="separator:a404c78dabf4df19e0cb2dd66d514848f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4854608c0e776f0704a4d9a4b98ea57d"><td class="memItemLeft" ><a class="anchor" id="a4854608c0e776f0704a4d9a4b98ea57d"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a4854608c0e776f0704a4d9a4b98ea57d">__pad3__</a>: 12</td></tr>
<tr class="memdesc:a4854608c0e776f0704a4d9a4b98ea57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">reserved <br/></td></tr>
<tr class="separator:a4854608c0e776f0704a4d9a4b98ea57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2edc85d90e34c4435951e1e5c59517"><td class="memItemLeft" ><a class="anchor" id="a7b2edc85d90e34c4435951e1e5c59517"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>__pad4__</b>: 0</td></tr>
<tr class="separator:a7b2edc85d90e34c4435951e1e5c59517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722aaf0c653219b547b7ff2984ae6ab7"><td class="memItemLeft" valign="top">&#160;&#160;&#160;}&#160;&#160;&#160;<b>usb_sts_bit</b></td></tr>
<tr class="separator:a722aaf0c653219b547b7ff2984ae6ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf67841f7fedc2644841617697bf35c"><td class="memItemLeft" valign="top">};&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:addf67841f7fedc2644841617697bf35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ff8b434596ea2719d532145cbe9351"><td class="memItemLeft" ><a class="anchor" id="ae8ff8b434596ea2719d532145cbe9351"></a>
union {</td></tr>
<tr class="memitem:aee3539bd214c9f1c3a5b35db1d086fa2"><td class="memItemLeft" ><a class="anchor" id="aee3539bd214c9f1c3a5b35db1d086fa2"></a>
&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#aee3539bd214c9f1c3a5b35db1d086fa2">usb_int_enable</a></td></tr>
<tr class="memdesc:aee3539bd214c9f1c3a5b35db1d086fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This register enables and disables reporting of the corresponding interrupt to the software. When a bit is set and the corresponding interrupt is active, an interrupt is generated to the host. Interrupt sources that are disabled in this register still appear in the USBSTS to allow the software to poll for events. <br/></td></tr>
<tr class="separator:aee3539bd214c9f1c3a5b35db1d086fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497ab81b6aef2f83e2c6ed87d058cbb4"><td class="memItemLeft" ><a class="anchor" id="a497ab81b6aef2f83e2c6ed87d058cbb4"></a>
&#160;&#160;&#160;struct {</td></tr>
<tr class="memitem:a6e60f608783dd4476b3b8ecab7066eb3"><td class="memItemLeft" ><a class="anchor" id="a6e60f608783dd4476b3b8ecab7066eb3"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a6e60f608783dd4476b3b8ecab7066eb3">usb</a>: 1</td></tr>
<tr class="memdesc:a6e60f608783dd4476b3b8ecab7066eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">When this bit is a one, and the USBINT bit in the USBSTS register is a one, the host controller will issue an interrupt at the next interrupt threshold. The interrupt is acknowledged by software clearing the USBINTbit. <br/></td></tr>
<tr class="separator:a6e60f608783dd4476b3b8ecab7066eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fedc196af2d4d152fd32b0783c78d7f"><td class="memItemLeft" ><a class="anchor" id="a6fedc196af2d4d152fd32b0783c78d7f"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a6fedc196af2d4d152fd32b0783c78d7f">usb_error</a>: 1</td></tr>
<tr class="memdesc:a6fedc196af2d4d152fd32b0783c78d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">When this bit is a one, and the USBERRINT bit in the USBSTS register is a one, the host controller will issue an interrupt at the next interrupt threshold. The interrupt is acknowledged by software clearing the USBERRINTbit. <br/></td></tr>
<tr class="separator:a6fedc196af2d4d152fd32b0783c78d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa893558e628e58f2f183cbedbf4863b7"><td class="memItemLeft" ><a class="anchor" id="aa893558e628e58f2f183cbedbf4863b7"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#aa893558e628e58f2f183cbedbf4863b7">port_change_detect</a>: 1</td></tr>
<tr class="memdesc:aa893558e628e58f2f183cbedbf4863b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">When this bit is a one, and the Port Change Detect bit in the USBSTS register is a one, the host controller will issue an interrupt. The interrupt is acknowledged by software clearing the Port Change Detectbit. <br/></td></tr>
<tr class="separator:aa893558e628e58f2f183cbedbf4863b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc16f083b47d7336fb7e70a2cc2ccc7"><td class="memItemLeft" ><a class="anchor" id="abbc16f083b47d7336fb7e70a2cc2ccc7"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#abbc16f083b47d7336fb7e70a2cc2ccc7">framelist_rollover</a>: 1</td></tr>
<tr class="memdesc:abbc16f083b47d7336fb7e70a2cc2ccc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">When this bit is a one, and the Frame List Rolloverbit in the USBSTS register is a one, the host controller will issue an interrupt. The interrupt is acknowledged by software clearing the Frame List Rollover bit. <br/></td></tr>
<tr class="separator:abbc16f083b47d7336fb7e70a2cc2ccc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1fa66147939da3bd3f7e84d4c79fd43"><td class="memItemLeft" ><a class="anchor" id="ac1fa66147939da3bd3f7e84d4c79fd43"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#ac1fa66147939da3bd3f7e84d4c79fd43">pci_host_system_error</a>: 1</td></tr>
<tr class="memdesc:ac1fa66147939da3bd3f7e84d4c79fd43"><td class="mdescLeft">&#160;</td><td class="mdescRight">(not used by NXP) When this bit is a one, and the Host System Error Statusbit in the USBSTS register is a one, the host controller will issue an interrupt. The interrupt is acknowledged by software clearing the Host System Error bit. <br/></td></tr>
<tr class="separator:ac1fa66147939da3bd3f7e84d4c79fd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6607680de70be131c44e27cc2f2c3cd"><td class="memItemLeft" ><a class="anchor" id="ac6607680de70be131c44e27cc2f2c3cd"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#ac6607680de70be131c44e27cc2f2c3cd">async_advance</a>: 1</td></tr>
<tr class="memdesc:ac6607680de70be131c44e27cc2f2c3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">When this bit is a one, and the Interrupt on Async Advancebit in the USBSTS register is a one, the host controller will issue an interrupt at the next interrupt threshold. The interrupt is acknowledged by software clearing the Interrupt on Async Advancebit. <br/></td></tr>
<tr class="separator:ac6607680de70be131c44e27cc2f2c3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e57c2ef1c3ffb36722f000cc1156824"><td class="memItemLeft" ><a class="anchor" id="a3e57c2ef1c3ffb36722f000cc1156824"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a3e57c2ef1c3ffb36722f000cc1156824">__pad0__</a>: 1</td></tr>
<tr class="memdesc:a3e57c2ef1c3ffb36722f000cc1156824"><td class="mdescLeft">&#160;</td><td class="mdescRight">reserved <br/></td></tr>
<tr class="separator:a3e57c2ef1c3ffb36722f000cc1156824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48bc1a0f022be1211fb852bd1d96965"><td class="memItemLeft" ><a class="anchor" id="ac48bc1a0f022be1211fb852bd1d96965"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#ac48bc1a0f022be1211fb852bd1d96965">nxp_int_sof</a>: 1</td></tr>
<tr class="memdesc:ac48bc1a0f022be1211fb852bd1d96965"><td class="mdescLeft">&#160;</td><td class="mdescRight">NXP customized: if this bit is one and the SRI bit in the USBSTS register is one, the host controller will issue an interrupt. In host mode, the SRI bit will be set every 125 micro sec and can be used by the host controller as a time base. The interrupt is acknowledged by software clearing the SRI bit in the USBSTS register. <br/></td></tr>
<tr class="separator:ac48bc1a0f022be1211fb852bd1d96965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6712ba6dd1d5b43d2d56ff8ac4e275a7"><td class="memItemLeft" ><a class="anchor" id="a6712ba6dd1d5b43d2d56ff8ac4e275a7"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a6712ba6dd1d5b43d2d56ff8ac4e275a7">__pad1__</a>: 10</td></tr>
<tr class="memdesc:a6712ba6dd1d5b43d2d56ff8ac4e275a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">reserved <br/></td></tr>
<tr class="separator:a6712ba6dd1d5b43d2d56ff8ac4e275a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f31fc1313f1e389a03738c07b9e325"><td class="memItemLeft" ><a class="anchor" id="ae7f31fc1313f1e389a03738c07b9e325"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#ae7f31fc1313f1e389a03738c07b9e325">nxp_int_async</a>: 1</td></tr>
<tr class="memdesc:ae7f31fc1313f1e389a03738c07b9e325"><td class="mdescLeft">&#160;</td><td class="mdescRight">NXP customized: When this bit is a one, and the USBHSTASYNCINT bit in the USBSTS register is a one, the host controller will issue an interrupt at the next interrupt threshold. The interrupt is acknowledged by software clearing the USBHSTASYNCINT bit. <br/></td></tr>
<tr class="separator:ae7f31fc1313f1e389a03738c07b9e325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404c78dabf4df19e0cb2dd66d514848f"><td class="memItemLeft" ><a class="anchor" id="a404c78dabf4df19e0cb2dd66d514848f"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a404c78dabf4df19e0cb2dd66d514848f">nxp_int_period</a>: 1</td></tr>
<tr class="memdesc:a404c78dabf4df19e0cb2dd66d514848f"><td class="mdescLeft">&#160;</td><td class="mdescRight">NXP customized: When this bit is a one, and the USBHSTPERINT bit in the USBSTS register is a one, the host controller will issue an interrupt at the next interrupt threshold. The interrupt is acknowledged by software clearing the USBHSTPERINT bit. <br/></td></tr>
<tr class="separator:a404c78dabf4df19e0cb2dd66d514848f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce12a63de64ef64ae2d59d128251cae"><td class="memItemLeft" ><a class="anchor" id="a9ce12a63de64ef64ae2d59d128251cae"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a9ce12a63de64ef64ae2d59d128251cae">__pad2__</a>: 12</td></tr>
<tr class="memdesc:a9ce12a63de64ef64ae2d59d128251cae"><td class="mdescLeft">&#160;</td><td class="mdescRight">reserved <br/></td></tr>
<tr class="separator:a9ce12a63de64ef64ae2d59d128251cae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4854608c0e776f0704a4d9a4b98ea57d"><td class="memItemLeft" ><a class="anchor" id="a4854608c0e776f0704a4d9a4b98ea57d"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>__pad3__</b>: 0</td></tr>
<tr class="separator:a4854608c0e776f0704a4d9a4b98ea57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497ab81b6aef2f83e2c6ed87d058cbb4"><td class="memItemLeft" valign="top">&#160;&#160;&#160;}&#160;&#160;&#160;<b>usb_int_enable_bit</b></td></tr>
<tr class="separator:a497ab81b6aef2f83e2c6ed87d058cbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ff8b434596ea2719d532145cbe9351"><td class="memItemLeft" valign="top">};&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:ae8ff8b434596ea2719d532145cbe9351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f60adb7ca73495905c236f23d474d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a05f60adb7ca73495905c236f23d474d6"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structehci__registers__t.html#a05f60adb7ca73495905c236f23d474d6">frame_index</a></td></tr>
<tr class="memdesc:a05f60adb7ca73495905c236f23d474d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This register is used by the host controller to index into the periodic frame list. The register updates every 125 microseconds (once each micro-frame). Bits [N:3] are used to select a particular entry in the Periodic Frame List during periodic schedule execution. The number of bits used for the index depends on the size of the frame list as set by system software in the Frame List Sizefield in the USBCMD register. <br/></td></tr>
<tr class="separator:a05f60adb7ca73495905c236f23d474d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0e38499dd86de20317ce89a4c074bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae0e38499dd86de20317ce89a4c074bc"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structehci__registers__t.html#aae0e38499dd86de20317ce89a4c074bc">ctrl_ds_seg</a></td></tr>
<tr class="memdesc:aae0e38499dd86de20317ce89a4c074bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">(not used by NXP) This 32-bit register corresponds to the most significant address bits [63:32] for all EHCI data structures. If the 64-bit Addressing Capabilityfield in HCCPARAMS is a zero, then this register is not used <br/></td></tr>
<tr class="separator:aae0e38499dd86de20317ce89a4c074bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0f624309b7e7068948d6cc1fe63da6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a0f624309b7e7068948d6cc1fe63da6"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structehci__registers__t.html#a7a0f624309b7e7068948d6cc1fe63da6">periodic_list_base</a></td></tr>
<tr class="memdesc:a7a0f624309b7e7068948d6cc1fe63da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This 32-bit register contains the beginning address of the Periodic Frame List in the system memory. System software loads this register prior to starting the schedule execution by the Host Controller (see 4.1). The memory structure referenced by this physical memory pointer is assumed to be 4-Kbyte aligned. The contents of this register are combined with the Frame Index Register (FRINDEX) to enable the Host Controller to step through the Periodic Frame List in sequence. <br/></td></tr>
<tr class="separator:a7a0f624309b7e7068948d6cc1fe63da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0b46810786774adba1dcee94c2b0ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba0b46810786774adba1dcee94c2b0ca"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structehci__registers__t.html#aba0b46810786774adba1dcee94c2b0ca">async_list_base</a></td></tr>
<tr class="memdesc:aba0b46810786774adba1dcee94c2b0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This 32-bit register contains the address of the next asynchronous queue head to be executed. Bits [4:0] of this register cannot be modified by system software and will always return a zero when read. The memory structure referenced by this physical memory pointer is assumed to be 32-byte (cache line) aligned. <br/></td></tr>
<tr class="separator:aba0b46810786774adba1dcee94c2b0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde3355c31e811ed52bb953ca8cb3396"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adde3355c31e811ed52bb953ca8cb3396"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structehci__registers__t.html#adde3355c31e811ed52bb953ca8cb3396">tt_control</a></td></tr>
<tr class="memdesc:adde3355c31e811ed52bb953ca8cb3396"><td class="mdescLeft">&#160;</td><td class="mdescRight">nxp embedded transaction translator (reserved by EHCI specs) <br/></td></tr>
<tr class="separator:adde3355c31e811ed52bb953ca8cb3396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9724a68645be69c67178229134aa21"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aac9724a68645be69c67178229134aa21"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structehci__registers__t.html#aac9724a68645be69c67178229134aa21">reserved</a> [8]</td></tr>
<tr class="memdesc:aac9724a68645be69c67178229134aa21"><td class="mdescLeft">&#160;</td><td class="mdescRight">reserved by EHCI specs <br/></td></tr>
<tr class="separator:aac9724a68645be69c67178229134aa21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf6bb470c1d14ab3923031b57734865"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbf6bb470c1d14ab3923031b57734865"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structehci__registers__t.html#acbf6bb470c1d14ab3923031b57734865">config_flag</a></td></tr>
<tr class="memdesc:acbf6bb470c1d14ab3923031b57734865"><td class="mdescLeft">&#160;</td><td class="mdescRight">(not used by NXP) configured flag register <br/></td></tr>
<tr class="separator:acbf6bb470c1d14ab3923031b57734865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf883a21ecbe4f2cb4dd916335fc8621"><td class="memItemLeft" ><a class="anchor" id="acf883a21ecbe4f2cb4dd916335fc8621"></a>
union {</td></tr>
<tr class="memitem:a8003e7311686c7ef8ab9b8a9a50c4573"><td class="memItemLeft" ><a class="anchor" id="a8003e7311686c7ef8ab9b8a9a50c4573"></a>
&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a8003e7311686c7ef8ab9b8a9a50c4573">portsc</a></td></tr>
<tr class="memdesc:a8003e7311686c7ef8ab9b8a9a50c4573"><td class="mdescLeft">&#160;</td><td class="mdescRight">port status and control <br/></td></tr>
<tr class="separator:a8003e7311686c7ef8ab9b8a9a50c4573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54dd3512c28a993e614623ee67d87ff7"><td class="memItemLeft" ><a class="anchor" id="a54dd3512c28a993e614623ee67d87ff7"></a>
&#160;&#160;&#160;struct {</td></tr>
<tr class="memitem:a58496bff225bdd838af09e528b201a0f"><td class="memItemLeft" ><a class="anchor" id="a58496bff225bdd838af09e528b201a0f"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a58496bff225bdd838af09e528b201a0f">current_connect_status</a>: 1</td></tr>
<tr class="memdesc:a58496bff225bdd838af09e528b201a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">RO 1=Device is present on port. 0=No device is present. Default = 0. This value reflects the current state of the port, and may not correspond directly to the event that caused the Connect Status Change bit (Bit 1) to be set. This field is zero if Port Power is zero. <br/></td></tr>
<tr class="separator:a58496bff225bdd838af09e528b201a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd8c7797b12f6e766180d74026c7ab0"><td class="memItemLeft" ><a class="anchor" id="a2fd8c7797b12f6e766180d74026c7ab0"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a2fd8c7797b12f6e766180d74026c7ab0">connect_status_change</a>: 1</td></tr>
<tr class="memdesc:a2fd8c7797b12f6e766180d74026c7ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">R/WC 1=Change in Current Connect Status. 0=No change. Default = 0. Indicates a change has occurred in the port's Current Connect Status. The host controller sets this bit for all changes to the port device connect status, even if system software has not cleared an existing connect status change. For example, the insertion status changes twice before system software has cleared the changed condition, hub hardware will be "setting" an already-set bit (i.e., the bit will remain set). Software sets this bit to 0 by writing a 1 to it. This field is zero if Port Power is zero. <br/></td></tr>
<tr class="separator:a2fd8c7797b12f6e766180d74026c7ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3116700ae96399bc2b639e419f725be4"><td class="memItemLeft" ><a class="anchor" id="a3116700ae96399bc2b639e419f725be4"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a3116700ae96399bc2b639e419f725be4">port_enable</a>: 1</td></tr>
<tr class="memdesc:a3116700ae96399bc2b639e419f725be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">1=Enable. 0=Disable. Default = 0. Ports can only be enabled by the host controller as a part of the reset and enable. Software cannot enable a port by writing a one to this field. The host controller will only set this bit to a one when the reset sequence determines that the attached device is a high-speed device. Ports can be disabled by either a fault condition (disconnect event or other fault condition) or by host software. Note that the bit status does not change until the port state actually changes. <br/></td></tr>
<tr class="separator:a3116700ae96399bc2b639e419f725be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38d11cf10ad5384ff62be4fed5ccc3a"><td class="memItemLeft" ><a class="anchor" id="aa38d11cf10ad5384ff62be4fed5ccc3a"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#aa38d11cf10ad5384ff62be4fed5ccc3a">port_enable_change</a>: 1</td></tr>
<tr class="memdesc:aa38d11cf10ad5384ff62be4fed5ccc3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">R/WC 1=Port enabled/disabled status has changed. 0=No change. Default = 0. For the root hub, this bit gets set to a one only when a port is disabled due to the appropriate conditions existing at the EOF2 point (See Chapter 11 of the USB Specification for the definition of a Port Error). Software clears this bit by writing a 1 to it. This field is zero if Port Power is zero. <br/></td></tr>
<tr class="separator:aa38d11cf10ad5384ff62be4fed5ccc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6b84aff30f539cc19f9c8d7607b9d6"><td class="memItemLeft" ><a class="anchor" id="ace6b84aff30f539cc19f9c8d7607b9d6"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#ace6b84aff30f539cc19f9c8d7607b9d6">over_current_active</a>: 1</td></tr>
<tr class="memdesc:ace6b84aff30f539cc19f9c8d7607b9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">RO Default = 0. 1=This port currently has an over-current condition. 0=This port does not have an over-current condition. This bit will automatically transition from a one to a zero when the over current condition is removed. <br/></td></tr>
<tr class="separator:ace6b84aff30f539cc19f9c8d7607b9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dcaa14f2998d9ae0a59c4e314446ced"><td class="memItemLeft" ><a class="anchor" id="a9dcaa14f2998d9ae0a59c4e314446ced"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a9dcaa14f2998d9ae0a59c4e314446ced">over_current_change</a>: 1</td></tr>
<tr class="memdesc:a9dcaa14f2998d9ae0a59c4e314446ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">R/WC Default = 0. 1=This bit gets set to a one when there is a change to Over-current Active. Software clears this bit by writing a one to this bit position. <br/></td></tr>
<tr class="separator:a9dcaa14f2998d9ae0a59c4e314446ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0938134b094fd1435eec21b8365a64c8"><td class="memItemLeft" ><a class="anchor" id="a0938134b094fd1435eec21b8365a64c8"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a0938134b094fd1435eec21b8365a64c8">force_port_resume</a>: 1</td></tr>
<tr class="memdesc:a0938134b094fd1435eec21b8365a64c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">1= Resume detected/driven on port. 0=No resume (K-state) detected/driven on port. Default = 0. This functionality defined for manipulating this bit depends on the value of the Suspendbit. For example, if the port is not suspended (Suspendand Enabledbits are a one) and software transitions this bit to a one, then the effects on the bus are undefined. Software sets this bit to a 1 to drive resume signaling. The Host Controller sets this bit to a 1 if a J-to-K transition is detected while the port is in the Suspend state. When this bit transitions to a one because a J-to-K transition is detected, the Port Change Detectbit in the USBSTS register is also set to a one. If software sets this bit to a one, the host controller must not set the Port Change Detectbit. <br/></td></tr>
<tr class="separator:a0938134b094fd1435eec21b8365a64c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ea72c12df3206cfaf4688148a3b091"><td class="memItemLeft" ><a class="anchor" id="aa7ea72c12df3206cfaf4688148a3b091"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#aa7ea72c12df3206cfaf4688148a3b091">suspend</a>: 1</td></tr>
<tr class="memdesc:aa7ea72c12df3206cfaf4688148a3b091"><td class="mdescLeft">&#160;</td><td class="mdescRight">1=Port in suspend state. 0=Port not in suspend state. Default = 0. Port Enabled Bit and Suspend bit of this register define the port states as follows: Bits [Port Enabled, Suspend] Port State 0X Disable 10 Enable 11 Suspend When in suspend state, downstream propagation of data is blocked on this port, except for port reset. The blocking occurs at the end of the current transaction, if a transaction was in progress when this bit was written to 1. In the suspend state, the port is sensitive to resume detection. Note that the bit status does not change until the port is suspended and that there may be a delay in suspending a port if there is a transaction currently in progress on the USB. A write of zero to this bit is ignored by the host controller. The host controller will unconditionally set this bit to a zero when: Software sets the Force Port Resumebit to a zero (from a one). Software sets the Port Resetbit to a one (from a zero). <br/></td></tr>
<tr class="separator:aa7ea72c12df3206cfaf4688148a3b091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e11f2fe465b3971a7b3bc1162928fa4"><td class="memItemLeft" ><a class="anchor" id="a9e11f2fe465b3971a7b3bc1162928fa4"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a9e11f2fe465b3971a7b3bc1162928fa4">port_reset</a>: 1</td></tr>
<tr class="memdesc:a9e11f2fe465b3971a7b3bc1162928fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">1=Port is in Reset. 0=Port is not in Reset. Default = 0. When software writes a one to this bit (from a zero) <br/></td></tr>
<tr class="separator:a9e11f2fe465b3971a7b3bc1162928fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9911b7e84b858661b407524f4bc2d2b1"><td class="memItemLeft" ><a class="anchor" id="a9911b7e84b858661b407524f4bc2d2b1"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a9911b7e84b858661b407524f4bc2d2b1">nxp_highspeed_status</a>: 1</td></tr>
<tr class="memdesc:a9911b7e84b858661b407524f4bc2d2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">NXP customized: 0=connected to the port is not in High-speed mode, 1=connected to the port is in High-speed mode. <br/></td></tr>
<tr class="separator:a9911b7e84b858661b407524f4bc2d2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e930b24d7f001b633246a2780ee9940"><td class="memItemLeft" ><a class="anchor" id="a4e930b24d7f001b633246a2780ee9940"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a4e930b24d7f001b633246a2780ee9940">line_status</a>: 2</td></tr>
<tr class="memdesc:a4e930b24d7f001b633246a2780ee9940"><td class="mdescLeft">&#160;</td><td class="mdescRight">hese bits reflect the current logical levels of the D+ (bit 11) and D- (bit 10) signal lines. These bits are used for detection of low-speed USB devices prior to the port reset and enable sequence. This field is valid only when the port enable bit is zero and the current connect status bit is set to a one. The encoding of the bits are: 00b SE0, 10b J-state, 01b K-state, 11b undefined <br/></td></tr>
<tr class="separator:a4e930b24d7f001b633246a2780ee9940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e4c5cfc259f34e52baad38060a2d45"><td class="memItemLeft" ><a class="anchor" id="ad1e4c5cfc259f34e52baad38060a2d45"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#ad1e4c5cfc259f34e52baad38060a2d45">port_power</a>: 1</td></tr>
<tr class="memdesc:ad1e4c5cfc259f34e52baad38060a2d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">0= power off, 1= power on, Host/OTG controller requires port power control switches. This bit represents the current setting of the switch (0=off, 1=on). When power is not available on a port (i.e. PP equals a 0), the port is non-functional and will not report attaches, detaches, etc. When an over-current condition is detected on a powered port and PPC is a one, the PP bit in each affected port may be transitioned by the host controller driver from a one to a zero (removing power from the port). <br/></td></tr>
<tr class="separator:ad1e4c5cfc259f34e52baad38060a2d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799501625702562ec594f6a2ae03a4be"><td class="memItemLeft" ><a class="anchor" id="a799501625702562ec594f6a2ae03a4be"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a799501625702562ec594f6a2ae03a4be">port_owner</a>: 1</td></tr>
<tr class="memdesc:a799501625702562ec594f6a2ae03a4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">(not used by NXP) <br/></td></tr>
<tr class="separator:a799501625702562ec594f6a2ae03a4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45723569bb7da28ed6c4ded0fd44b44"><td class="memItemLeft" ><a class="anchor" id="af45723569bb7da28ed6c4ded0fd44b44"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#af45723569bb7da28ed6c4ded0fd44b44">port_indicator_control</a>: 2</td></tr>
<tr class="memdesc:af45723569bb7da28ed6c4ded0fd44b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writing to this field effects the value of the pins USB0_IND1 and USB0_IND0. 00b: Port indication is off, 01b: Amber, 10b: green, 11b: undefined. <br/></td></tr>
<tr class="separator:af45723569bb7da28ed6c4ded0fd44b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07820834719fcfa649c32da23dc7b870"><td class="memItemLeft" ><a class="anchor" id="a07820834719fcfa649c32da23dc7b870"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a07820834719fcfa649c32da23dc7b870">port_test_control</a>: 4</td></tr>
<tr class="memdesc:a07820834719fcfa649c32da23dc7b870"><td class="mdescLeft">&#160;</td><td class="mdescRight">When this field is zero, the port is NOT operating in a test mode. A non-zero value indicates that it is operating in test mode. <br/></td></tr>
<tr class="separator:a07820834719fcfa649c32da23dc7b870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b6342eddbac6afd0498878dbe4f040"><td class="memItemLeft" ><a class="anchor" id="af2b6342eddbac6afd0498878dbe4f040"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#af2b6342eddbac6afd0498878dbe4f040">wake_on_connect_enable</a>: 1</td></tr>
<tr class="memdesc:af2b6342eddbac6afd0498878dbe4f040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default = 0b. Writing this bit to a one enables the port to be sensitive to device connects as wake-up events. See Section 4.3 for effects of this bit on resume event behavior. Refer to Section 4.3.1 for operational model. <br/></td></tr>
<tr class="separator:af2b6342eddbac6afd0498878dbe4f040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3f477b644b9608920375f3e489da41"><td class="memItemLeft" ><a class="anchor" id="a4d3f477b644b9608920375f3e489da41"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a4d3f477b644b9608920375f3e489da41">wake_on_disconnect_enable</a>: 1</td></tr>
<tr class="memdesc:a4d3f477b644b9608920375f3e489da41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default = 0b. Writing this bit to a one enables the port to be sensitive to device disconnects as wake-up events. See Section 4.3 for effects of this bit on resume event behavior. Refer to Section 4.3.1 for operational model. <br/></td></tr>
<tr class="separator:a4d3f477b644b9608920375f3e489da41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1838e319021e7dba82b0b74e5170fc"><td class="memItemLeft" ><a class="anchor" id="aeb1838e319021e7dba82b0b74e5170fc"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#aeb1838e319021e7dba82b0b74e5170fc">wake_on_over_current_enable</a>: 1</td></tr>
<tr class="memdesc:aeb1838e319021e7dba82b0b74e5170fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default = 0b. Writing this bit to a one enables the port to be sensitive to over-current conditions as wake-up events. See Section 4.3 for effects of this bit on resume event behavior. Refer to Section 4.3.1 for operational model. <br/></td></tr>
<tr class="separator:aeb1838e319021e7dba82b0b74e5170fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c9de4ce08c88d7e7dbddd7707d7d90"><td class="memItemLeft" ><a class="anchor" id="a14c9de4ce08c88d7e7dbddd7707d7d90"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a14c9de4ce08c88d7e7dbddd7707d7d90">nxp_phy_clock_disable</a>: 1</td></tr>
<tr class="memdesc:a14c9de4ce08c88d7e7dbddd7707d7d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">NXP customized: the PHY can be put into Low Power Suspend  Clock Disable when the downstream device has been put into suspend mode or when no downstream device is connected. Low power suspend is completely under the control of software. 0: enable PHY clock, 1: disable PHY clock. <br/></td></tr>
<tr class="separator:a14c9de4ce08c88d7e7dbddd7707d7d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b0e0f9ce4fb61a1aa95e8db2901bef"><td class="memItemLeft" ><a class="anchor" id="a78b0e0f9ce4fb61a1aa95e8db2901bef"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#a78b0e0f9ce4fb61a1aa95e8db2901bef">nxp_port_force_fullspeed</a>: 1</td></tr>
<tr class="memdesc:a78b0e0f9ce4fb61a1aa95e8db2901bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">NXP customized: Writing this bit to a 1 will force the port to only connect at Full Speed. It disables the chirp sequence that allowsthe port to identify itself as High Speed. This is useful for testing FS configurations with a HS host, hub or device. <br/></td></tr>
<tr class="separator:a78b0e0f9ce4fb61a1aa95e8db2901bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e57c2ef1c3ffb36722f000cc1156824"><td class="memItemLeft" ><a class="anchor" id="a3e57c2ef1c3ffb36722f000cc1156824"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>__pad0__</b>: 1</td></tr>
<tr class="separator:a3e57c2ef1c3ffb36722f000cc1156824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61049d4c309d378d92ea98668051c0b"><td class="memItemLeft" ><a class="anchor" id="ad61049d4c309d378d92ea98668051c0b"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<a class="el" href="structehci__registers__t.html#ad61049d4c309d378d92ea98668051c0b">nxp_port_speed</a>: 2</td></tr>
<tr class="memdesc:ad61049d4c309d378d92ea98668051c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">NXP customized: This register field indicates the speed atwhich the port is operating. For HS mode operation in the host controllerand HS/FS operation in the device controller the port routing steers data to the Protocol engine. For FS and LS mode operation in the host controller, the port routing steers data to the Protocol Engine w/ Embedded Transaction Translator. 0x0: Fullspeed, 0x1: Lowspeed, 0x2: Highspeed. <br/></td></tr>
<tr class="separator:ad61049d4c309d378d92ea98668051c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6712ba6dd1d5b43d2d56ff8ac4e275a7"><td class="memItemLeft" ><a class="anchor" id="a6712ba6dd1d5b43d2d56ff8ac4e275a7"></a>
&#160;&#160;&#160;&#160;&#160;&#160;uint32_t&#160;&#160;&#160;<b>__pad1__</b>: 0</td></tr>
<tr class="separator:a6712ba6dd1d5b43d2d56ff8ac4e275a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54dd3512c28a993e614623ee67d87ff7"><td class="memItemLeft" valign="top">&#160;&#160;&#160;}&#160;&#160;&#160;<b>portsc_bit</b></td></tr>
<tr class="separator:a54dd3512c28a993e614623ee67d87ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf883a21ecbe4f2cb4dd916335fc8621"><td class="memItemLeft" valign="top">};&#160;</td><td class="memItemRight" valign="bottom"></td></tr>
<tr class="separator:acf883a21ecbe4f2cb4dd916335fc8621"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Field Documentation</h2>
<a class="anchor" id="a3e57c2ef1c3ffb36722f000cc1156824"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t __pad0__</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reserved </p>
<p>These bits are reserved and should be set to zero. </p>

</div>
</div>
<a class="anchor" id="a6712ba6dd1d5b43d2d56ff8ac4e275a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t __pad1__</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reserved </p>
<p>These bits are reserved and should be set to zero. </p>

</div>
</div>
<a class="anchor" id="a9ce12a63de64ef64ae2d59d128251cae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t __pad2__</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reseved </p>
<p>reserved </p>

</div>
</div>
<a class="anchor" id="ac6607680de70be131c44e27cc2f2c3cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t async_advance</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>R/WC 0=Default. System software can force the host controller to issue an interrupt the next time the host controller advances the asynchronous schedule by writing a one to the Interrupt on Async Advance Doorbell bit in the USBCMD register. This status bit indicates the assertion of that interrupt source. </p>
<p>When this bit is a one, and the Interrupt on Async Advancebit in the USBSTS register is a one, the host controller will issue an interrupt at the next interrupt threshold. The interrupt is acknowledged by software clearing the Interrupt on Async Advancebit. </p>

</div>
</div>
<a class="anchor" id="abbc16f083b47d7336fb7e70a2cc2ccc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t framelist_rollover</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>R/WC The Host Controller sets this bit to a one when the Frame List Index(see Section 2.3.4) rolls over from its maximum value to zero. The exact value at which the rollover occurs depends on the frame list size. For example, if the frame list size (as programmed in the Frame List Sizefield of the USBCMD register) is 1024, the Frame Index Registerrolls over every time FRINDEX[13] toggles. Similarly, if the size is 512, the Host Controller sets this bit to a one every time FRINDEX[12] toggles. </p>
<p>When this bit is a one, and the Frame List Rolloverbit in the USBSTS register is a one, the host controller will issue an interrupt. The interrupt is acknowledged by software clearing the Frame List Rollover bit. </p>

</div>
</div>
<a class="anchor" id="ae7f31fc1313f1e389a03738c07b9e325"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nxp_int_async</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>R/WC NXP customized: This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set andthe TD was from the asynchronous schedule. This bit is also set by the Host when a short packet is detected andthe packet is on the asynchronous schedule. </p>
<p>NXP customized: When this bit is a one, and the USBHSTASYNCINT bit in the USBSTS register is a one, the host controller will issue an interrupt at the next interrupt threshold. The interrupt is acknowledged by software clearing the USBHSTASYNCINT bit. </p>

</div>
</div>
<a class="anchor" id="a404c78dabf4df19e0cb2dd66d514848f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nxp_int_period</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>R/WC NXP customized: This bit is set by the Host Controller when the cause of an interrupt is a completion of a USB transaction where the Transfer Descriptor (TD) has an interrupt on complete (IOC) bit set andthe TD was from the periodic schedule. </p>
<p>NXP customized: When this bit is a one, and the USBHSTPERINT bit in the USBSTS register is a one, the host controller will issue an interrupt at the next interrupt threshold. The interrupt is acknowledged by software clearing the USBHSTPERINT bit. </p>

</div>
</div>
<a class="anchor" id="ac48bc1a0f022be1211fb852bd1d96965"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nxp_int_sof</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>R/WC NXP customized: this bit will be set every 125us and can be used by host controller driver as a time base. </p>
<p>NXP customized: if this bit is one and the SRI bit in the USBSTS register is one, the host controller will issue an interrupt. In host mode, the SRI bit will be set every 125 micro sec and can be used by the host controller as a time base. The interrupt is acknowledged by software clearing the SRI bit in the USBSTS register. </p>

</div>
</div>
<a class="anchor" id="ac1fa66147939da3bd3f7e84d4c79fd43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pci_host_system_error</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>R/WC (not used by NXP) The Host Controller sets this bit to 1 when a serious error occurs during a host system access involving the Host Controller module. In a PCI system, conditions that set this bit to 1 include PCI Parity error, PCI Master Abort, and PCI Target Abort. When this error occurs, the Host Controller clears the Run/Stop bit in the Command register to prevent further execution of the scheduled TDs. </p>
<p>(not used by NXP) When this bit is a one, and the Host System Error Statusbit in the USBSTS register is a one, the host controller will issue an interrupt. The interrupt is acknowledged by software clearing the Host System Error bit. </p>

</div>
</div>
<a class="anchor" id="aa893558e628e58f2f183cbedbf4863b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t port_change_detect</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>R/WC The Host Controller sets this bit to a one when any port for which the Port Ownerbit is set to zero (see Section 2.3.9) has a change bit transition from a zero to a one or a Force Port Resumebit transition from a zero to a one as a result of a J-K transition detected on a suspended port. </p>
<p>When this bit is a one, and the Port Change Detect bit in the USBSTS register is a one, the host controller will issue an interrupt. The interrupt is acknowledged by software clearing the Port Change Detectbit. </p>

</div>
</div>
<a class="anchor" id="a6e60f608783dd4476b3b8ecab7066eb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t usb</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>R/WC The Host Controller sets this bit to 1 on the completion of a USB transaction, which results in the retirement of a Transfer Descriptor that had its IOC bit set. <br/>
 The Host Controller also sets this bit to 1 when a short packet is detected (actual number of bytes received was less than the expected number of bytes). </p>
<p>When this bit is a one, and the USBINT bit in the USBSTS register is a one, the host controller will issue an interrupt at the next interrupt threshold. The interrupt is acknowledged by software clearing the USBINTbit. </p>

</div>
</div>
<a class="anchor" id="a6fedc196af2d4d152fd32b0783c78d7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t usb_error</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>R/WC The Host Controller sets this bit to 1 when completion of a USB transaction results in an error condition (e.g., error counter underflow). If the TD on which the error interrupt occurred also had its IOC bit set, both this bit and USBINT bit are set. See Section 4.15.1 for a list of the USB errors that will result in this bit being set to a one. </p>
<p>When this bit is a one, and the USBERRINT bit in the USBSTS register is a one, the host controller will issue an interrupt at the next interrupt threshold. The interrupt is acknowledged by software clearing the USBERRINTbit. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>tinyusb/host/ehci/<a class="el" href="ehci_8h_source.html">ehci.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structehci__registers__t.html">ehci_registers_t</a></li>
    <li class="footer">Generated on Wed Mar 26 2014 16:23:19 for tinyusb by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
